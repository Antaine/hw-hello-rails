# Part 3: Create CRUD routes, actions, and views for Movies


Start the app with \T{rails~server~-p~\$PORT~-b~\$IP}, as in
Section~\ref{sec:http}. 
Once the server has started, Cloud9 will show a small popup box saying
something like 
``Your code is running at
\T{https://}\emph{workspace}--\emph{username}.\T{c9users.io}''.  We will
refer to this as the app's \emph{root-URI}.
Recall from Chapter~\ref{chap:arch} that a URI
\index{Uniform Resource Identifier (URI)!Rails basics}%
such as this one that specifies only a hostname (and possibly a port)
will fetch the app's home page.  For a brand-new Rails app without any
code, this page is the  ``Welcome to Rails'' splash page you see.  
\begin{sidebar}[-1in]{Not using Cloud9?}
  If developing locally, just say \T{rails~server}, and the root-URI
  will be \T{http:/\slash{}localhost:3000}.
\end{sidebar}

If you now try the URI \emph{root-URI}\/\T{/movies}
(that is, 
\T{https://}\emph{workspace}--\emph{username}.\T{c9users.io\slash{}movies}
if developing on Cloud9, or
\T{http:/\slash{}localhost:3000\slash{}movies}
if developing on your own computer),
should get a Routing Error from Rails.  Indeed, you should verify that
\emph{anything} you add after the hostname part of the URI results in this error, 
because we haven't specified any \x{routes}
\index{Routes!Rails basics}%
 mapping URIs to app
methods.  Try \T{rake~routes} and verify that unlike the result in
Chapter~\ref{chap:arch}, it informs us that there are no routes in our brand-new app.  
\begin{sidebar}[-0.3in]{Don't forget}
  that this really means
  \T{bundle exec rake routes}.
\end{sidebar}
(You may want to open multiple Terminal windows or tabs so that the app can keep
running while you try other commands.)
More importantly,
use an editor to open the file \T{log/development.log} and observe that
the error message is logged there; this is where you look to find
detailed error information when something goes wrong.  We'll show other
problem-finding and debugging techniques in Section~\ref{sec:thingsgowrong}.

\label{sec:resourceful_routes}

To fix this error we need to add some routes.  Since our initial goal is
to store movie information in a database, we can take advantage of a
Rails shortcut that creates RESTful
\index{Representational State Transfer (REST)!CRUD}%
 routes for the four basic CRUD
 \index{CRUD!Rails basics}%
  actions
(Create, Read, Update, Delete) on a model.  (Recall that
RESTful routes specify self-contained requests of what operation to
perform and what entity, or resource, to perform it on.)  Edit
\T{config\slash{}routes.rb}, which was auto-generated by the
\T{rails~new} command and is heavily commented.  Replace the contents of
the file with the following (the file is mostly comments, so you're not
actually deleting much):

\codefile[294ff740da2b016784c8]{ch_rails/code/routes.rb}

Save the \T{routes.rb} file and run \T{rake~routes} again, and observe that because of
our change to \T{routes.rb}, the first line of output says that the URI
\T{GET~/movies} will try to call the \T{index} action of the \T{movies}
controller; this and most of the other routes in the table are the
result of the line \C{resources~:movies}, as we'll soon see.  The root
route \T{'/'}, RottenPotatoes' ``home page,'' will take us to the main
Movie listings page by a mechanism we'll soon see called an \w[URL
  redirection]{HTTP redirect}\index{HTTP redirect, Rails basics}. 
\begin{sidebar}[-1in]{Symbol or string?}%
	\index{String!symbol comparison|textit}%
	\index{Symbol!string comparison|textit}%
  As with many Rails methods, \C{resources 'movies'} would also work,
  but a symbol usually indicates
  one of a fixed set of choices rather than an arbitrary string.
\end{sidebar}%  

Using convention over configuration, 
\coc
Rails will expect
this controller's actions to be defined in the class
\C{MoviesController},
  \index{MoviesController class!Rails basics}%
and if that class isn't defined at application
start time, Rails will try to load it from the file
\T{app\slash{}controllers\slash{}movies\_controller.rb}.  Sure enough,
if you now reload the page  \emph{root-URI}\/\T{/movies} in your
browser, you should see a different error: \T{uninitialized constant
  MoviesController}.  This is good news: a Ruby class name is just a
constant that refers to the class object, so Rails is essentially
complaining that it can't find the \C{MoviesController} class,
indicating that our route is working correctly!  As before, this error
message and additional information are captured in the log file
\T{log\slash{}development.log}. 

Having covered the first two steps in the list---setting up the app
skeleton and creating some initial routes---we can move on to setting up
the database that will store the models, the ``M'' of MVC.

\begin{summary}
 \B{Summary:} You used the following commands to set up a new Rails app:
  \index{Reloading, Rails app example|textit}%
 \begin{itemize}
  \item \T{rails new} sets up the new app; the \T{rails} command also
    has subcommands to run 
    the app locally with WEBrick (\T{rails server}) and other management tasks.
  \item Rails and the other gems your app depends on (we added the Haml
    templating)
    are listed in the app's \T{Gemfile}, which Bundler uses to automate
    the process of creating a consistent environment for your app
    whether in development or production mode.
  \item To add routes
  \index{Routes!non-resource-based|textit}%
   in 
    \T{config\slash{}routes.rb}, the one-line \T{resources} method provided by
    the Rails routing system allowed us to set up a group of related
    routes for CRUD
	\index{Representational State Transfer (REST)!CRUD|textit}% 
    actions on a RESTful resource.
  \item The log files in the \T{log} directory collect error information
    when something goes wrong.
 \end{itemize}
\end{summary}

\begin{elaboration}{Automatically reloading the app}
  You may have noticed that after changing \T{routes.rb}, you didn't
  have to stop and restart the app in order for the changes to take
  effect.  In development mode, Rails reloads all of the app's classes
  on every new request, so that your changes take effect immediately.
  In production this would cause serious performance
  problems, so Rails provides ways to change various app behaviors
  between development and production mode, as we'll see in
  Section~\ref{sec:rails_databases}. 
\end{elaboration}


\index{Routes!wildcard tokens|textit}%
\index{Wildcards!routes|textit}%
\index{Controllers!routes|textit}%
\tablefigure{ch_rails/tables/route_example_table}{fig:route_example_table}%
{As the Elaboration explains, routes can include ``wildcard'' tokens
  such as  \C{:controller} and
  \C{:action}, which determine the controller and action that will
  be invoked.  Any other tokens beginning with \C{:}, plus any
  additional parameters encoded in the URI, will be made available in the
  \C{params}
  \protect\index{params[]!Rails app example|textit}%
   hash.
}

\begin{elaboration}{Non-resource-based routes}
  The shortcut \C{resources :movies} creates RESTful routes for CRUD,
  but any nontrivial app
  will have many additional controller actions beyond CRUD.  The
  \weblink{http://guides.rubyonrails.org/v3.2.19/routing.html}{Rails Routing
    from the Outside In guide} has much more detail, but one way to set
  up routes is to map components of the URI
  \protect\index{Uniform Resource Identifier (URI)!params hash|textit}% 
  directly to controller and
  action names using wildcards, as Figure~\ref{fig:route_example_table} shows.
\end{elaboration}

\begin{checkyourself}
  Recall the generic Rails welcome page you saw when you first created
  the app.
  In the \T{development.log} file, 
  what is happening when the line \T{Started GET
    "assets/rails.png"} is printed?  (Hint: recall the steps needed to
  render a page containing embedded assets, as described in
  Section~\ref{sec:10k}.) 
  \begin{answer}
    The browser is requesting the embedded image of the Rails logo for the
    welcome page.
  \end{answer}
\end{checkyourself}
